---
layout: post
title: "Software qualities: what they are and how can you improve them"
lang: en
date: 2021-04-22
permalink: software-qualities
---

<p>
  I've found myself in many situations where I am either reviewing my own or someone else's code and I keep thinking that I am probably not considering something that I should.
  I also try to help my company develop better software and there's probably a lot more stuff we could do but I can't think of any.
  These events led me to investigate what makes software great.
  I organized all my knowledge and all I could find about software qualities in one place that I could regularly check to ensure I'm not forgetting something.
  This is that place.
</p>

<p>
  In this post I will try to explain what each quality is about.
  These are the qualities I'm most familiar with as a professional software engineer.
  My experience mainly consists on developing and maintaining a private equity marketplace, accessible via web applications.
  In total I've got <em>11</em> qualities.
  They are, in no particular order: correctness, availability, efficiency, security, maintainability, adaptability, usability, usefulness, stability, community and support, and pricing.
  Depending on where you consult, each standards commitee has its own list of qualities, all of which I found too narrow as they mainly focused on requirements specification and implementation and didn't consider qualities such as usefulness, pricing, and others, which I find essential for software to be considered good.
  If you want to learn more about what others think of this matter, I found <a href="https://en.wikipedia.org/wiki/Software_quality">the Wikipedia article</a> a good starting point.
</p>

<p>
  There's an infinite amount of things one can do to improve each quality.
  There's so much that large organizations tend to hire severals specialists to focus on just one.
  In this post I will also try to provide a small list of suggestions for each quality, highly based on my experience, which should let you get started.
</p>

<p>
  This article will not explain why you should (or should not) follow each of my suggestions.
  It just lists them.
  I recommend searching for the suggestion in the Internet to learn more about it.
  This article will also not explain which metrics you should monitor to understand how you're doing in a given quality.
</p>

<h3>How can you improve any quality?</h3>
<p>There is a small list of suggestions I find applicable to improve any quality, which are:</p>

<ul>
  <li>Build, measure, learn, prioritize, repeat.</li>
  <li>Foster critical thinking.</li>
  <li>Prefer data-driven decisions.</li>
  <li>Don't wait for problems to happen. Proactively try to find them.</li>
  <li>Split tasks and responsibilities among different people.</li>
</ul>

<h2>Table of contents</h2>

<ol>
  <li><a href="#correctness">Correctness</a></li>
  <li><a href="#availability">Availability</a></li>
  <li><a href="#efficiency">Efficiency</a></li>
  <li><a href="#security">Security</a></li>
  <li><a href="#maintainability">Maintainability</a></li>
  <li><a href="#adaptability">Adaptability</a></li>
  <li><a href="#usability">Usability</a></li>
  <li><a href="#usefulness">Usefulness</a></li>
  <li><a href="#stability">Stability</a></li>
  <li><a href="#community-and-support">Community and Support</a></li>
  <li><a href="#pricing">Pricing</a></li>
</ol>

<h2 id="correctness">1. Correctness</h2>

<p>
  Correctness means that the software works as expected by the software makers.
  It's the first thing engineers try to do, which is <cite>"Make it work"</cite>.
  I personally believe that behaviors that were not expected and also not supported cannot be considered bugs, otherwise everything is a bug.
</p>

<p>How can you make your software less buggy?</p>

<h3>Re-use</h3>
<ul>
  <li>Prefer buying or re-using (open-source or private) software instead of building your own.</li>
</ul>

<h3>Test</h3>
<ul>
  <li>Test your software against a set of automated and manual tests.</li>
  <li>Perform demos with stakeholders.</li>
</ul>

<h3>Misunderstandings</h3>
<ul>
  <li>Understand as much as possible what are the requirements and the reasons why you need that new feature.</li>
  <li>Really try to understand how a system works and be able to explain the impact of your changes.</li>
  <li>Challenge complex features.</li>
  <li>Remove features as much as possible.</li>
</ul>

<h3>Detect and don't forget about bugs</h3>
<ul>
  <li>Track your errors and bugs (using Airbrake, Github issues, JIRA).</li>
  <li>Maintain a communication channel where users can report bugs.</li>
  <li>Add ability to use the software exactly like your users.</li>
  <li>Monitor health metrics.</li>
  <li>Monitor user behavior.</li>
  <li>Implement data integrity checks specifically adapted to your data models.</li>
</ul>

<h3>Avoid bugs with automation</h3>
<ul>
  <li>Use statically-typed programming languages.</li>
  <li>Use programming languages with garbage collection.</li>
</ul>

<h3>Concurrency</h3>
<ul>
  <li>Understand how concurrency affects your software. Your code might have race conditions.</li>
  <li>Prefer using functions and immutable data structures over mutating shared state.</li>
</ul>

<h3>Failures (machine, network)</h3>
<ul>
  <li>Make your code idempotent.</li>
  <li>Use database transactions if you use a relational database.</li>
  <li>Check if your dependencies can receive idempotency keys like <a href="https://stripe.com/docs/idempotency">Stripe</a>.</li>
</ul>

<h3>Let others help you</h3>
<ul>
  <li>Implement a code review process.</li>
  <li>Implement and follow coding conventions.</li>
  <li>Make most decisions with other team members before you start coding.</li>
  <li>Regularly become up-to-date with best practices.</li>
</ul>

<h2 id="availability">2. Availability</h2>

<p>
  Availability means that the software is available to be used.
  This quality is related with resilience, which is the ability to handle failures, and with recoverability or self-healing, which is the ability to recover from failures.
</p>

<p>How can you make your software more available?</p>

<h3>Re-use</h3>
<ul>
  <li>Prefer paying for a service instead of managing your own.</li>
</ul>

<h3>Avoid failures</h3>
<ul>
  <li>Use a job system that allows you to run code in the background and where jobs are retried when they fail.</li>
  <li>Test how your software performs under stress.</li>
  <li>Simulate failures (using tools like <a href="https://netflix.github.io/chaosmonkey/">Chaos Monkey</a>).</li>
  <li>Do post-mortems when there are incidents.</li>
  <li>Understand how your software is deployed. Your code might be causing down-time.</li>
  <li>Use infrastructure in the cloud over on-premise. It enables auto-scaling.</li>
</ul>

<h3>Detect failures</h3>
<ul>
  <li>Monitor your availability (e.g. use Datadog, Pingdom, status pages of 3rd party dependencies).</li>
  <li>Monitor health metrics (both hardware-wise and product-wise).</li>
</ul>

<h3>Recover from failures</h3>
<ul>
  <li>Implement a reliability incident response process.</li>
  <li>Regularly perform data backups.</li>
  <li>Blue-green deployments.</li>
  <li>Phased rollouts.</li>
</ul>

<h3>Let others help you</h3>
<ul>
  <li>Regularly become up-to-date with best practices.</li>
</ul>

<h2 id="efficiency">3. Efficiency</h2>

<p>
  Software is said to be efficient when it requires as few resources as possible, where resources can be time (CPU, GPU, people's), memory space, disk space, energy, money, network bandwidth, and others.
  Users typically notice more when software is slow (time).
  In most cases, the reason why software is slow is because of how it works (code) and not due to lack of resources.
</p>

<p>How can you make your software more efficient?</p>

<h3>Re-use</h3>
<ul>
  <li>Prefer buying or re-using (open-source or private) software instead of building your own.</li>
</ul>

<h3>Prevent and detect</h3>
<ul>
  <li>Compare the current performance with the theoretical maximum.</li>
  <li>Think about performance when designing your software.</li>
  <li>Test how your software performs under stress.</li>
  <li>Monitor performance (e.g. using profilers or services like Datadog) in both development and production.</li>
  <li>Understand how the code works.</li>
  <li>Understand how systems are interacting.</li>
  <li>Understand the platform that is running the software (e.g. web browser, hardware).</li>
  <li>Use tools that suggest performance improvements (e.g. N+1 database query detectors).</li>
  <li>
    Create performance tests that run automatically.
    This will allow you to detect regressions.
  </li>
</ul>

<h3>Improve</h3>
<ul>
  <li>Design your code to handle multiple items at a time instead of a single item at a time.</li>
  <li>Use database indexes if you use a relational database.</li>
  <li>Consider de-normalizing data.</li>
  <li>Read <a href="https://www.dataorienteddesign.com/dodbook/">Data-Oriented Design</a>.</li>
</ul>

<h3>Let others help you</h3>
<ul>
  <li>Implement a code review process.</li>
  <li>Create a performance culture.</li>
</ul>

<h2 id="security">4. Security</h2>

<p>
  Security means how likely attackers might breach the software, i.e., interrupt its activity, gain access to sensitive information, change its behavior to achieve some other goal (e.g. mine Bitcoin).
  Software can never be completely secure.
  Given enough time and money, any software can be hacked.
</p>

<p>How can you make your software more secure?</p>

<h3>Re-use</h3>
<ul>
  <li>Prefer buying or re-using (open-source or private) software instead of building your own. Just because your software doesn't have public CVEs doesn't mean it's more secure.</li>
</ul>

<h3>Detect</h3>
<ul>
  <li>Run security vulnerability scanners (e.g. Brakeman).</li>
  <li>Regularly check security vulnerability databases or directly track CVEs.</li>
  <li>Use tools that monitor logs and detect suspicious behavior.</li>
  <li>Use tools that monitor traffic and detect suspicious behavior.</li>
  <li>Create threat models for your systems and processes (e.g. following <a href="https://en.wikipedia.org/wiki/STRIDE_%28security%29">STRIDE</a>).</li>
</ul>

<h3>Prevent</h3>
<ul>
  <li>Keep software dependencies and tooling up-to-date.</li>
  <li>Follow the strategy of defense-in-depth.</li>
  <li>Follow the principle of least privilege.</li>
  <li>Don't assume or trust. Instead, verify.</li>
  <li>Keep data encrypted as much as possible.</li>
  <li>
    Data can be both a liability and an asset.
    Regularly check if it still makes sense to keep that type of data.
  </li>
</ul>

<h3>Test</h3>
<ul>
  <li>Try to attack your software.</li>
  <li>Hire penetration testing services to find security vulnerabilities in your software.</li>
</ul>

<h3>Let others help you</h3>
<ul>
  <li>Learn more about existing types of security vulnerabilities.</li>
  <li>Implement a code review process.</li>
  <li>Regularly become up-to-date with best practices.</li>
  <li>Compare your systems architecture with best practices (like <a href="https://docs.aws.amazon.com/wellarchitected/latest/security-pillar/welcome.html">AWS Well-Architected Framework</a>).</li>
</ul>

<h2 id="maintainability">5. Maintainability</h2>

<p>
  Maintainable software means it's easier to understand and to change (only small things like bug fixing, not including adding new features).
  It's also easy to build, run, test, install and update.
</p>

<p>How can you make your software more maintainable?</p>

<h3>Standardize</h3>
<ul>
  <li>Set and follow coding conventions.</li>
  <li>Use tooling to standardize code instead of making up (e.g. Rails, Rubocop, Ruby).</li>
  <li>Automate continuous integration (CI) and continuous deployment (CD).</li>
</ul>

<h3>Simplify</h3>
<ul>
  <li>Understand as much as possible what are the requirements and the reasons why you need that new feature.</li>
  <li>Remove features as much as possible.</li>
  <li>Consider multiple designs and their trade-offs before settling with a solution.</li>
  <li>Refactor code to better reflect the new knowledge.</li>
  <li>Maximize cohesion and minimize coupling. In other words, put together what is related, and make independent what can be independent.</li>
  <li>Prefer using functions and immutable data structures over mutating shared state.</li>
  <li>Minimize number of systems.</li>
  <li>Prefer homogeneus over heterogeneous. In other words, keep the tech stack small.</li>
  <li>Use tools to detect unused code.</li>
</ul>

<h3>Document</h3>
<ul>
  <li>Use version control software.</li>
  <li>Document important decisions.</li>
  <li>Document projects. The code didn't appear there just because.</li>
  <li>Document systems and their interactions.</li>
  <li>Document APIs.</li>
</ul>

<h3>Let others help you</h3>
<ul>
  <li>Implement a code review process.</li>
  <li>Maximize knowledge sharing between team members and across teams.</li>
  <li>Regularly perform retrospectives where you and your team can discuss of what went well, what went wrong and how it can be improved.</li>
</ul>

<h3>Monitor</h3>
<ul>
  <li>Monitor which systems require more time to be changed.</li>
</ul>

<h2 id="adaptability">6. Adaptability</h2>

<p>
  Adaptability means that the software easily adapts to new situations such as new features, new platforms, new hardware, new user interfaces, etc.
  For me adaptability and maintainability are two different qualities of software because, first, it's possible to have software that is maintainable but is not adaptable, and second, it's very hard to make software adaptable.
  The main reason that seems to make software really hard to adapt is that humans are complicated, and the software that has to model or interact with stuff created by humans is even more complicated.
</p>

<p>How can you make your software more adaptable?</p>

<h3>Simplify</h3>
<ul>
  <li>Maximize cohesion and minimize coupling. In other words, put together what is related, and make independent what can be independent.</li>
  <li>Challenge complex features.</li>
  <li>Remove features as much as possible.</li>
</ul>

<h2 id="usability">7. Usability</h2>

<p>
  Usability is related with user interfaces.
  When a software is highly usable, people call it <em>intuitive</em>.
  It's software that is as simple as possible to use.
  It's easy to understand.
  It follows appropriate language for its goals.
  It's consistent.
  It's pretty.
  It follows standard conventions.
  It uses the appropriate communication channels to communicate with users depending on the message.
</p>

<p>How can you make your software more usable?</p>

<h3>Re-use</h3>
<ul>
  <li>
    Prefer buying or re-using (open-source or private) a UI component library instead of building your own.
    If you build one, document it.
  </li>
</ul>

<h3>User feedback</h3>
<ul>
  <li>Test the software with users.</li>
  <li>Maintain a communication channel (e.g. email, Intercom) to receive user feedback.</li>
  <li>
    Gather quantitative and qualitative data from users.
    Better if you can get quantitative data from users without explicit user input.
  </li>
</ul>

<h3>Research</h3>
<ul>
  <li>Get to know the different types of users of the software (e.g. for an investing platform that might be investors, entrepreneurs, staff).</li>
  <li>Understand the users' needs you're trying to fulfill.</li>
  <li>Prototype multiple designs before settling on one.</li>
  <li>
    Understand how the software works and the data it manipulates.
    Reading documentation or talking with engineers will most certainly help.
  </li>
  <li>Learn more about how users interact with the platform where your software runs.</li>
  <li>Document user journeys.</li>
</ul>

<h3>Execution</h3>
<ul>
  <li>Participate in demos to ensure your designs are being correctly implemented.</li>
</ul>

<h3>Simplify</h3>
<ul>
  <li>Remove features as much as possible.</li>
  <li>Follow the conventions of the platform the software is running on.</li>
</ul>

<h3>Let others help you</h3>
<ul>
  <li>Understand what are the industry standard user interfaces for your type of software.</li>
  <li>Learn more about how to best use each communication channel.</li>
  <li>Perform demos with stakeholders.</li>
</ul>

<h2 id="usefulness">8. Usefulness</h2>

<p>
  Software is said to be useful when it solves some users' needs.
  The more needs it solves the more useful it is.
  It's also more useful when it can be used in different situations.
  For example, a text editor is more useful if it allows to edit more types of text.
</p>

<p>How can you make your software more useful?</p>

<h3>User feedback</h3>
<ul>
  <li>Maintain a communication channel (e.g. email, Intercom) to receive user feedback.</li>
  <li>Maintain a forum where users can talk with the team and with other users about the software.</li>
  <li>
    Gather quantitative and qualitative data from users.
    Better if you can get quantitative data from users without explicit user input.
  </li>
</ul>

<h3>Research</h3>
<ul>
  <li>Get to know the different types of users of the software (e.g. for an investing platform that might be investors, entrepreneurs, staff).</li>
  <li>Document users needs.</li>
  <li>
    Understand if the software is solving users' needs.
    This requires understanding both the software as well as users' needs.
  </li>
  <li>Run ideation sessions to generate new ideas.</li>
  <li>Understand how network effects benefit your software.</li>
  <li>Understand how quantity of data benefits your software.</li>
</ul>

<h3>Prioritization</h3>
<ul>
  <li>Prioritize needs and problems that need to be addressed.</li>
</ul>

<h3>Complexity</h3>
<ul>
  <li>Explain users needs to other people involved in developing the software.</li>
  <li>Participate in demos to ensure your features are being correctly implemented.</li>
  <li>Think about the trade-offs of every feature.</li>
</ul>

<h3>Announcements</h3>
<ul>
  <li>Provide documentation for the software so users can discover new solutions.</li>
  <li>Publish release notes.</li>
</ul>

<h2 id="stability">9. Stability</h2>

<p>
  Software is stable when it minimizes breaking changes.
  This is specially applicable to software used by other software engineers, but it also applies to GUIs.
</p>

<p>What can you do to make your software more stable?</p>

<ul>
  <li>Think about the trade-offs of introducing that breaking change.</li>
  <li>Forbid breaking changes, <a href="https://linuxreviews.org/WE_DO_NOT_BREAK_USERSPACE">like Linux does</a>.</li>
  <li>Introduce versioning.</li>
  <li>Phased rollouts.</li>
</ul>

<h2 id="community-and-support">10. Community and Support</h2>

<p>
  Software is said to be supportive when it has at least one communication channel where users can ask for help and have their questions and concerns cleared.
  It's the team of humans that is always ready to help users and to be their voice when talking with the remaining team members.
</p>

<p>How can you make your software more supportive?</p>

<ul>
  <li>Empathise with the user.</li>
  <li>Act upon user feedback.</li>
  <li>Get to know the team to better understand who to ask for help when you don't know how to answer a user.</li>
  <li>Create FAQs.</li>
  <li>Maintain a forum where users can talk with the team and with other users about the software.</li>
  <li>Monitor how long it takes to help a user.</li>
  <li>Monitor how many users have been helped over time.</li>
</ul>

<h2 id="good-price">11. Pricing</h2>

<p>
  Software is said to have a good price when users are happy to pay for that price to be able to use your software.
  Nowadays a lot of software isn't paid directly but indirectly (as part of a service).
  I still think it makes sense to include pricing as a quality of software, even if that pricing includes more than paying for the software.
</p>

<p>How can you improve your pricing?</p>

<ul>
  <li>Learn more about pricing models.</li>
  <li>Identify how much the alternatives to your softwares cost.</li>
  <li>Test multiple prices.</li>
  <li>
    Be aware of how much your software costs to you and question if each of its costs are worth the benefits.
    Involve your team members as they might have more context of why you have some cost and also might be aware of cheaper solutions to those needs.
  </li>
  <li>
    Raise money from investors.
    It will allow you to support losses longer, hopefully until you have more users that make the cost per user equation favourable.
  </li>
</ul>
